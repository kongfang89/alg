### 一、概念

定义$1$：若$m|(a-b)$，即$a\space mod\space m=b\space mod\space m$，则称$a,b$**同余**，记作$a\equiv b(mod\space m)$

定义$2$：若$a\times x \equiv 1 (mod\space b)$，且$a,b$互质，则称$x$为$a$在$mod\space b$意义下的**逆元(倒数)**，记作$a^{-1}$



Q：逆元有什么用？

A：如果我们想计算$\frac{a}{b}\space mod\space p$的值，显然在$a$不能被$b$整除时，原式为分数$mod$整数，通常的模运算无法计算。此时，基于逆元的定义，可以推出$\frac{a}{b}\space mod\space p=a\times b^{-1}\space mod\space p$，也即计算出$b$的逆元就得到了$\frac{a}{b}\space mod\space p$​的值。

### 二、计算逆元的方法

##### 1.快速幂

​	**费马小定理：**若有素数$p$​，正整数$a$​，且$a,p$​互质，则有$a^{p-1}\equiv 1(mod\space p)$​

​	设$a$​​的逆元为$x$​​

​	$\because a\times x\equiv 1(mod\space p)$  $\therefore a\times x\equiv a^{p-1}(mod\space p)$  $\therefore x\equiv a^{p-2}(mod\space p)$

​	此时我们用快速幂计算出$a^{p-2}$就是$a$​的逆元了

```c++
ll a,p;

ll ksm(ll x,ll n){
    x%=p;
    ll res=1;
    while(n){
        if(n&1)
            	res=(res*x)%p;
        x=(x*x)%p;
        n>>=1;
    }
    return res;
}

int main(){
    cin>>a>>p;
    cout<<ksm(a,p-2)<<'\n';
    return 0;
}
```

##### 2.扩展欧几里得算法

​	求解$a\times x \equiv 1(mod\space p)$，也即求解$a\times x+b\times y=1$方程中$(x,y)$的解，解出来的$x$就是$a$的逆元

```c++
ll a,p;

void exgcd(ll a,ll b,ll &x,ll &y){
	if(b==0){
        x=1;
        y=0;
    }
    else{
        exgcd(b,a%b,y,x);
        y-=a/b*x;
    }
}

int main(){
    cin>>a>>p;
    ll x,y;
    exgcd(a,p,x,y);
    cout<<x<<'\n';
    return 0;
}
```

##### 3.线性递推

​	显然有$1\equiv 1(mod\space p)$，令$inv[i]$表示$i$在$mod\space p$意义下的逆元，任意$p$都有$inv[i]=1$

​	又有$p\equiv 0(mod\space p)$，设$p=k\times i+r$，即$k$为$p/i$的商，余数为$r$

​	可推出$k\times i+r\equiv 0(mod\space p)$

​	两边同时乘以$i^{-1}\times r^{-1}$

​	得$k\times r^{-1}+i^{-1}\equiv 0(mod\space p)$

​	得$i^{-1}\equiv -k\times r^{-1} (mod\space p)$

​	得$i^{-1}\equiv -\lfloor \frac{p}{i}\rfloor \times (p\space mod\space i)^{-1}(mod\space p)$

​	因此，我们只需要知道$inv[p\%i]$即可递推得出$inv[i]$的值，而$p\%i<i$，所以从小到大递推即可。

```c++
ll a,p;

int main(){
	cin>>a>>p;
	ll inv[MAX_N];
	inv[1]=1;
	for(int i=2;i<=a;i++)
		inv[i]=(ll)(p-p/i)*inv[p%i]%p;
	cout<<inv[a]<<'\n';
	return 0;
}
```

##### 4.阶乘求逆元

​	有$inv[i+1]=\frac{1}{(i+1)!}$，$inv[i+1]\times (i+1)=\frac{1}{i!}=inv[i]$

​	因此，先求出$n!$的逆元$inv[n!]=\frac{1}{n!}$，即可逆推计算出$[1,n!-1]$的逆元

​	$inv[i]=inv[i+1]\times(i+1)$

​	$inv[i]=inv[i!]\times (i-1)!$

```c++
ll a,p;
//阶乘数组
ll c[MAX_N];
//阶乘的逆元数组
ll fact_inv[MAX_N];

ll ksm(ll x,ll n){
    x%=p;
    ll res=1;
    while(n){
        if(n&1)
            	res=(res*x)%p;
        x=(x*x)%p;
        n>>=1;
    }
    return res;
}

int main(){
	cin>>a>>p;
    //计算[0,n]的阶乘
    c[0]=1;
	for(int i=1;i<=n;i++)
		c[i]=(c[i-1]*i)%p;
    //计算n!的逆元
    fact_inv[n]=ksm(c[n],p-2);
    //逆推出所有i!的逆元
    for(int i=n-1;i>=1;i--)
        fact_inv[i]=(fact_inv[i+1]*(i+1))%p;
    cout<<(fact_inv[a]*c[a-1])%p<<'\n';
	return 0;
}
```

