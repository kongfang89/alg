### 一、概念

**扫描线**是一种求平面上所有矩形面积并的算法，采用线段树维护。

### 二、算法原理

**扫描线**可以横着扫(平行于x轴)也可以竖着扫(平行于y轴)，对应的线段树维护横坐标$x_{1...2n}$或纵坐标$y_{1...2n}$的信息：被覆盖次数，所截长度。

通俗理解就是把平面所有矩形按一个方向一刀刀切开，再分别统计小矩形的面积求和。

#### 具体实现：

以横着扫为例，平面内每个矩形有左下角和右上角两个点的坐标信息，用一个数组$X$存放$n$个矩形的左右横坐标$x1,x2$，再用一个数组$line$保存每个矩形的上下边的信息(左横坐标$x1$，右横坐标$x2$，纵坐标$y$，上下边标记$c=1/-1$)，显然这两个数组都有$2n$个元素，接下来对$line$数组按高度升序排序，对$X$数组按横坐标升序排序，由于每个矩形的横坐标可能有重合，需要对$X$数组去重(unique即可)。

接下来就是建树，树的每个节点保存信息：左端点$l$，右端点$r$，被完全覆盖的次数$sum$，区间内被截断的长度$len$。

$push\_up$的话，判断是否被覆盖过($sum>0$)，如果被覆盖过，则需更新被截断的长度为线段长度；如果没有被覆盖过，截断长度就是左右儿子的截断长度和。

$update$的话，如果当前要修改的区间$[L,R]$在当前节点的$[l,r]$内，$sum+=c$，即更新当前节点被覆盖次数，$c=1$是下边，$c=-1$是上边，这里对$sum$的修改类似于差分思想；再$push\_up$一下，继续递归$update$左右节点。

最后统计$ans$，对于每一条扫描边$i$，它贡献的面积$S=T[1].len\times (line[i+1].h-line[i].h)$，把$[1,2n-1]$扫描边的贡献统计一下即可，最后一条不需要统计。

### 三、代码

```c++
#include <bits/stdc++.h>
#define INF 99999999
#define LINF LLONG_MAX
#define ls (x<<1)
#define rs (x<<1|1)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int MAX_N=1000010;

int n,cnt;
ll x1,yy1,x2,y2,X[MAX_N<<1];
ll ans;

struct node{
	ll l,r,h;
	int mark;
	bool operator <(const node &a) const{
		return h<a.h;
	}
}line[MAX_N<<1];

struct tree{
	int l,r,sum;
	ll len;
}T[MAX_N<<2];

void build(int x,int l,int r){
	T[x].l=l;
	T[x].r=r;
	T[x].len=0;
	T[x].sum=0;
	if(l==r)
		return;
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	return;
}

void push_up(int x){
	int l=T[x].l,r=T[x].r;
	if(T[x].sum)
		T[x].len=X[r+1]-X[l];
	else
		T[x].len=T[ls].len+T[rs].len;
}

void update(int x,ll L,ll R,int cnt){
	int l=T[x].l,r=T[x].r;
	if(X[r+1]<=L||R<=X[l])
		return;
	if(L<=X[l]&&X[r+1]<=R){
		T[x].sum+=cnt;
		push_up(x);
		return;
	}
	update(ls,L,R,cnt);
	update(rs,L,R,cnt);
	push_up(x);
}

int main(){
	freopen("1.in","r",stdin);
	ios_base::sync_with_stdio(false);
	cout.tie(0);
	cin.tie(0);
	//freopen("1.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x1>>yy1>>x2>>y2;
		X[2*i-1]=x1;
		X[2*i]=x2;
		line[2*i-1]=(node){x1,x2,yy1,1};
		line[2*i]=(node){x1,x2,y2,-1};
	}
	n<<=1;
	sort(line+1,line+n+1);
	sort(X+1,X+n+1);
	int tot=unique(X+1,X+n+1)-(X+1);
	build(1,1,tot-1);
	for(int i=1;i<n;i++){
		update(1,line[i].l,line[i].r,line[i].mark);
		ans+=T[1].len*(line[i+1].h-line[i].h);
	}
	cout<<ans<<'\n';
	return 0;
}

/*
样例
2
100 100 200 200
150 150 250 255
输出
18000
*/
```

